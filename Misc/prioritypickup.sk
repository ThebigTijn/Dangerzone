local function addAtt(p:player,pl:player):
    add (uuid of {_pl}) to {-att.%uuid of {_p}%::*}

local function removeAtt(p:player):
    set {_u} to (uuid of {_p})
    loop {-att.%{_u}%::*}:
        delete {-hits.%loop-value%.%{_u}%}
    delete {-att.%{_u}%::*}

local function returnHits(p:player) :: numbers:
    set {_u} to (uuid of {_p})
    loop {-att.%{_u}%::*}:
        add {-hits.%loop-value%.%{_u}%} to {_nums::*}
    return {_nums::*}

local function ...(p:player):
    set {_nums::*} to returnHit({_p})
    set {_high} to max({_nums::*})
    set {_u} to (uuid of {_p})
    loop {-att.%{_u}%::*}:
        {-hits.%loop-value%.%{_u}%} = {_high}
        ...({_p},loop-value)

local function ...(p:player,uuid:string) :: items:
    loop all items in (inventory of {_p}):
        set (string tag "custom;priority" of nbt of loop-value) to {_uuid}
        add loop-value to {_items::*}
    ...({_items::*})
    return {_items::*}

local function ...(items:items):
    drop {_items::*}
    wait 10 seconds
    loop {_items::*}:
        delete (string tag "custom;priority" of nbt of loop-value)

on pickup:
    (string tag "custom;priority" of nbt of event-item) is set
    (string tag "custom;priority" of nbt of event-item) != uuid of player
    stop

on damage:
    addAtt(victim,attacker) if {-att.%uuid of victim%::*} does not contain (uuid of attacker)
    add 1 to {-hits.%uuid of attacker%.%uuid of victim%}